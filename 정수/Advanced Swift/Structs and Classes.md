# Structs and Classes
---

<br>

Swift에서는 데이터를 저장하기 위한 구조적 데이터 타입을 다양하게 지원합니다.

Swift의 표준 라이브러리 내 대부분의 Public 타입들의 경우에는 `struct`로 정의되어 있습니다.

이번 챕터에서는 `struct` 와 `class`의 차이점에 대해 자세히 살펴보도록 하겠습니다.

아래 내용은 `struct` 와 `class` 간 주요 차이점에 대한 내용입니다.

- `Struct(enum)` 은 값(value) 타입인 반면 `class`는 참조(reference) 타입입니다. 구조체를 이용할때는 컴파일러에게 불변성을 강제할 수 있습니다.
- 메모리 관리 방법에 차이가 존재합니다. 구조체는 인스턴스 생성시 값을 복사하기 때문에 직접적으로 접근하는 반면 클래스의 인스턴스는 참조를 이용하여 간접적으로 접근하게 됩니다. 즉 구조체는 소유자가 단일이지만 클래스의 인스턴스는 소유자가 여럿이 될 수 있습니다.
- 클래스의 경우, 상속을 이용하여 부모 클래스의 코드를 공유할 수 있는 반면, 구조체의 경우 상속이 불가합니다. 

<br>

### Value Types
---

기본적으로 Swift의 구조체는 불변성을 지닙니다. 이를 이용하여 코드를 작성하는 것이 이해하기도 수월하며 `thread-safe` 한 장점을 지닐 수 있습니다.

Swift의 구조체는 `value`를 저장하기 위해 고안되었습니다. 구조체는 참조를 이용하여 비교가 불가하며 오직 구조체의 속성값을 기반으로 비교가 가능합니다.

구조체 속성에 대한 변경은 개념적으로 완전히 새로운 구조체를 변수에 할당하는 것과 동일한 개념입니다.

구조체 인스턴스의 소유자는 단 한명만이 될 수 있지만, 함수의 인자로 구조체 변수를 전달하게 되면 함수는 해당 구조체의 복사본을 전달받게 됩니다.

그리고 그 내부에서는 복사본에 대한 변경만이 발생합니다. 이를 우리는 `Value sementaics, Copy semantics` 라고 부릅니다.

이와는 반대로 참조 타입의 경우에는 참조를 전달하기 때문에 소유자가 여럿이 될 수 있으며 이를 우리는 `Reference semantics` 라고 부릅니다.

구조체 인스턴스를 생성할 때 마다 값을 복사한다는 것이 비효율적이라는 생각이 들 수 있지만 컴파일러가 불필요한 복사 연산을 최적화 해줍니다.

<br>

### Structs
---

값 타입은 앞서 설명했듯 참조 방식이 아닌 값을 복사하는 방식으로 인스턴스가 생성됩니다.

간단한 예시로 Swift에서 사용하는 `CGPoint` 타입과 유사한 예시를 임의로 만들어 보도록 하겠습니다.

```swift
struct Point {
    var x: Int
    var y: Int
}
```

Swift의 구조체는 기본적으로 구조체 멤버별 생성자를 제공합니다. 이 말인 즉슨 별도의 생성자를 작성하지 않고도 아래와 같이 인스턴스 생성이 가능하다는 의미입니다.

```swift
let origin = Point(x: 0, y: 0)
```

`Point` 타입의 인스턴스를 생성하는데 `let` 키워드를 통해 생성하였습니다.

따라서 불변성을 지니기 때문에 해당 인스턴스의 속성을 변경하고자 한다면 에러가 발생합니다.

`Point` 구조체 내부에 프로퍼티를 `var` 키워드를 통해 선언하였음에도 불구하고 우리는 이 프로퍼티값을 변경할 수 없습니다.

```swift
origin.x = 10       // Error
```


그렇다면 이번에는 값 변경이 가능한 변수를 생성해보도록 할꼐요.

```swift
var otherPoint = Point(x: 0, y: 0)
otherPoint.x += 10
otherPoint      //(x: 10, y: 0)
```

위 인스턴스는 `var` 키워드를 통해 변수로 선언되었으므로 내부 프로퍼티 값 변경이 가능합니다.

<br>

### Copy-On-Write
---

Swift 표준 라이브러리의 콜렉션(ex: 배열, 딕셔너리, 집합..etc) 등은 `Copy-On-Write` 라는 기술을 기반으로 구현되었습니다.

Int 타입의 배열을 예시로 `Copy-On-Write` 에 대해 알아보도록 할께요.

```swift
var x = [1, 2, 3]
var y = x
```

위와 같이 x라는 변수 Int 타입 배열을 하나 생성하였습니다.

그리고 이를 y에 대입하였습니다.

`y` 라는 변수를 생성할때 `x` 값의 복사본이 생성되고 이를 `y`에 대입합니다.

참조를 공유하는 방법이 아닌 값을 복사하여 대입했기에 `x`, `y`는 각각 독립적으로 존재합니다.

이 간단한 코드 두 줄 사이에 Swift에서는 꽤나 많은 일들이 일어납니다.

각각의 배열들은 내부적으로 실제 배열의 원소들이 저장될 메모리 버퍼에 대한 참조를 갖습니다.

위 코드와 같이 원본 혹은 복사본에 대하여 별도 작업을 진행하지 않은 경우  `x` 와 `y` 는 동일한 버퍼의 참조를 갖습니다.

즉 저장소를 공유한다는 의미이죠.

그러나 `x` 혹은 `y` 내부 원소에 대한 값이 변경된다면 그때 실질적으로 서로 다른 버퍼 저장소를 가지고 분리하여 값에 대한 변경을 진행합니다.

이러한 동작을 `Copy-On-Write` 라고 부르며 이를 통해 불필요한 복사의 경우 리소스를 줄일수 있게 됩니다.

<br>

### Memory
---

값 타입의 경우에는 단일 오너를 갖기 때문에 메모리 관리가 매우 수월합니다.

그러나 참조 타입의 경우에는 메모리 관리가 상대적으로 어려우며 이를 잘못 사용하면 순환 참조가 발생하여 메모리 누수가 발생할 수 있습니다.

```swift
struct Person {
    let name: String
    var parent: [Person]
}

var john = Person(name: "John", parents: [])
john.parents = [john]
```

배열에 `john`을 추가할때, Person이 값 타입이기 때문에 값의 복사가 일어납니다.

만일 `Person` 타입이 값 타입이 아닌 참조 타입이었다면 순환 참조 문제가 발생합니다.

Swift에서는 참조 타입의 경우 ARC(Automatic Reference Counting)을 이용하여 메모리를 관리합니다.

객체에 대한 레퍼런스를 생성하게 되면 retain이 발생하여 레퍼런스 카운트가 증가하게 되고 참조가 해제되면 레퍼런스 카운트가 감소합니다.

그리고 이 객체에 대한 레퍼런스 카운트가 0이 되면 ARC에 의해 해당 객체는 소멸됩니다.

그러나 만일 위와 같이 순환 참조 문제가 발생한다면 서로가 서로를 강하게 참조하고 있기 때문에 레퍼런스 카운트가 감소하지 않게되고 결국 메모리 누수가 발생하게 됩니다.

<br>